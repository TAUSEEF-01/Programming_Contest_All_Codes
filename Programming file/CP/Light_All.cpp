/*
I am THE_BEST_no_1

@@@@@@@@@@@@@########################SSS%#%%SS#SS##SSSSSSS%%?%%SS#######################@@@@@@@@@@@@
@@@@@@############################S%SS#%SSS?%%##%SS#SSSSS%S%%??%S#@##############@@@@@@@@@@@@@@@@@@@
@################################S?*SS#?S%%?**%#S%SSSSSSS%%%%???%S#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
################################S?**%%S?%S%????%#SSSSSSSSS%%SSS%SSS#@@@@@@@@@@@@@@@@@@@@@@@@@###@@@@
###########################@@@@#?*?*?SSS%S#S%%S%%S#SSS#SSSSSS#######@@#@############################
###################@@@@@@@@@@@@%?*%%%S#S#SS@#S%S#SSS#SSS###SSS##@####@######################@@@@@@@@
##########@@@@@@@@@@@@@@@@@@@@S?S%?%SSS######@#S#@##SSSSS%S#@####@#@##@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S?SS%%%S%S######@@##@@@##SSSSS#@@@@@@@##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@?S##S%##SSSS#@@@@@@@@@@@@@##@@@@@@@@@@##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@?%##@#SS###SS##@@@@@@######@@@@@@@@@@@@##@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%#S#@@@###@@@##@@#S##@##@#S###@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#####@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%####@S%#####@@@###%%S**%?*%%%####@@@@@@@@@@@@@@@@@@@##@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#S@@###S?*%#S??SS?*%?+++++++*?S###@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##@@###*;++*++;+%*+++++++++;*%S###@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###@%?%*++++++;*%?++++++++++?%#SS@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#*+*+++++++*%%%++++++++++?SS#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S+;+++++++?%?*++++++++++SS#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S*;+++++++++++++++++++%S%#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#?+;++++***+++++++++?S%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##S*+;++++**+++++;+%S%%S##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#S*+++++++++++*SS%%%S%S%#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S%@#*?*+;;+;;+%S%%%%S%%%?%##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#%?++S#?+?%?***%SS%%%%%S%%???%SS#@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#S%%S%%%%**?*;+%#?;*?%%S%%%%%%?%S%%????SSSS###@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@###SSS%%%???????%%?**?*;;;?S*;+*?%%%%%%%%S%%?????#SSSSS%??S@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@#SSSS%%%%??????????%***?+;;;;*%?+;+*??%?%%%S%%????%#SSSSSSS%??S##@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@#SSSSSS%%%%%%%????????**??;;;;+S%?%*+++++*%%%????***????????%%%%?*?*?%S##@@@@@@@@@@@
@@@@@@@@@@@@@@@#SSSSSSS%%%%%%%%???%????*%+;;+*S@S??%?+++*???**??**???????????%%SS?********?%S#@@@@@@
@@@@@@@@@@@@@@@#SSS##SSS%%%%%%%%%%??????%++**+*###S%%%?**+++++++*???%%SSSSSSSSSSSS%************?%S#@
@@@@@@@@@@#######SS##SSSS%%%%%%%%%%%%%%%?%?++;;*S#S?*++++++*?%%?*********?%#SSSSSSS?***************?
@@@@@@@@@############SSSS%%%%%%%%%%%SSS%%S?**+***+++++++++++++*??%%%%%%??***%SSSSS?***********??****
@@@@@@@@#############SSSSSSSSS%%%%%%%%?***???**+++++++++++?%%?*******%SSSSS?**?S%?************?*****
@@@@@@##@@@@@########SSSSSS%%%%%%%?S%***+?*+++++++++++++++;+*?***???**?%SSS%????*************?******
@@@@@@@@@@@######SSSSSSSSSS%%%%%%%%S****?%**++++++++**????*++++++;+%?%%?*??*****************??******
@@@@@@@@#########SSSSSSSSSS%%%%%%%S?****?%*******??%%%SSS###S?*++*?%**??%??%***************%%**?????
@@@@@@@###########SSSSSSSSSS%%%%%S%*****?S%SSS%%%%?*+*+*%S#@@SS%+*%?*******%?*************%S????????
@@@@@@@###########SSSSSSSSSS#S##SS?*****%S%%%?*?%+;;;*;;++?#####?+%?******?SS?***********%S???????%S
@@@@@@@@##########SSSSSS###S#####S%???%%%%%%S*++*?*++*;;+**%####S?*?******SS?**********?%S??????%S##
@@@@@@@@############SS############S%%%%%%SSS%?*+++**+*+++;+?######SSS%?**%S%*****??****%S?????%S####
@@@@@@@@###########################SSSSS%%%S%%%*++++*****+++*S########@#S#%******?%***?S????%S######
@@@@@@@@@@@@@@@@@@@@@@#################%%%?%S%%%?+++++*+++++++?##@#####@@@#S%????%S%%%%%??%S########
@@@@@@@@@@@@@@@@@@@@@@@@@@###########SS%%%%%S%%%%*++++**+++++++*##@@@#S##@@@@###################SSSS
@@@@@@@@@@@@@@@@@@@@@@@@@####SSSSSSS%%%S%%%%%S%%%?*****?+******+*#@@@#%S#%SSSS%%%%SS%%SS##@####SSSSS
@@@@@@@@@@@@@@@@@@@@@@@@@#####SSSSSSSSS%SS%%%SS%%?*****%*********%@@@@@@S?????????S#S?%S%S#@@@@@@@##
@@@@@@@@@@@@@@@@@@@@@@@@@@#######SSSSSSSSSS%%%SSS????**%*********?##@@@@@S%%??????%S#S%#S%%S#@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@########SSSSSSSSSS%S#S%?????%?????????%SS#@@@@@@###SS%%%S##S###SSSS#@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@##########SSSSSSSSS#SS%%??%%????%%%%?%S%SS##SSSSSSS########S######SS##@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@############SSSS#SS#SSS%%S%%SSSSS%%%%SSSS##%%%%%%%%%SS#@@@@###@@#######
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##############S##S##SSSS#SSSSS###SS%SSSS##SSSSSSSSSSS####@@@@@@@@@@###

*/

#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

#define ll long long
#define ull unsigned long long
#define pb push_back
#define ff first
#define ss second
#define all(a) a.begin(), a.end()
#define reall(a) a.rbegin(), a.rend()
#define vsort(a) sort(all(a))
#define revsort(a) sort(reall(a))
#define vmin(a) *min_element(all(a))
#define vmax(a) *max_element(all(a))
#define loop(i, k, n) for (ll i = k; i < n; i++)
#define Loop(i, k, n) for (ll i = k; i <= n; i++)
using vi = vector<int>;
using vl = vector<ll>;
using vvi = vector<vi>;
using vvl = vector<vl>;
using vs = vector<string>;
using vb = vector<bool>;
using pii = pair<int, int>;

typedef unordered_map<ll, ll> umll;
typedef map<ll, ll> mll;
typedef priority_queue<ll> pqll;
typedef priority_queue<pair<ll, ll>> pqpll;
typedef priority_queue<int, vector<int>, greater<int>> pqrll;
typedef priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pqrpll;
typedef priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pqrppll;

#define get_bit(n, pos) (bool)(n & (1 << pos))
#define set_bit(n, pos) (n | (1 << pos))
#define clear_bit(n, pos) (n & (~(1 << pos)))
#define update_bit(n, pos, value) ((clear_bit(n, pos)) | (value << pos))

#define lower_case(a) transform(a.begin(), a.end(), a.begin(), ::tolower)
#define upper_case(a) transform(a.begin(), a.end(), a.begin(), ::toupper)

#define ub_pos(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()
#define lb_pos(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()
#define bins(a, n) binary_search(a.begin(), a.end(), n) // returns true or false value

#define toint(a) atoi(a.c_str())
#define total_sum(a) accumulate(a.begin(), a.end(), 0LL)
#define vrot(a, rot_by) rotate(a.begin(), a.end() - rot_by, a.end())

#define mem(a, x) memset(a, x, sizeof(a))
#define nxp(v) next_permutation(v.begin(), v.end());

/**/
#define input(a)      \
    for (auto &x : a) \
        cin >> x;

#define output(a)         \
    for (auto &x : a)     \
        cout << x << ' '; \
    cout << endl;

/**/
#define yes \
    cout << "YES\n"

#define no \
    cout << "NO\n"

/**/
const ll mod = 1e9 + 7, inf = 1e18;
const double pi = acos(-1);
#define dbg(a) cerr << __LINE__ << ": " << #a << " = " << a << '\n'

/*
int rotate_by = k % (n + 1);
rotate(a.begin(), a.end() - rotate_by, a.end());
*/

/*
# bitset<66> bits(x); //bitset operation --> converts any number to bits, can mention how many bits we want; here 66 bits that we want
//using the following operation we can convert the bits into string:

    string res="";
    res=bits.to_string();

//using the following operation we can exclude the extra 0's that comes in front of the number:

    reverse(res.begin(), res.end());
    while(res.back()=='0')
    {
        res.pop_back();
    }
    reverse(res.begin(), res.end());

here if 4 -> 000000100  is found using bitset; by using the above method we can get 100 the required bits only.
*/

// if(s1.compare(s2) == 0) {cout << s << " is equal to " << s1 << endl;} --> here s1 and s2 are 2 strings and we are comparing these strings; if == 0 than they are same otherwise different
// string s = "dog:cat";  int pos = s.find(":");  string sub = s.substr(pos + 1);   // Copy substring after pos; -->  String is: cat
// string s1 = "Geeks";   string r = s1.substr(3, 2);   // Copy two characters of s1 (starting from position 3); -->  String is: ks

/**/
//__int128(n)*mid*mid*4 <-- Here n*mid*mid*4 is written using --> __int128() which may not support in 64 bit computer
// but this is used for calculating large int value that can't be processed in i64 or long long

/* ################################ Functions ############################### */
// ########################################################################## //

// ll power(ll x, ll y)
// {
//     ll res = 1;
//     x = x;
//     if (x == 0)
//         return 0;

//     while (y > 0)
//     {
//         if (y & 1)
//             res = (res * x);
//         y = y >> 1;
//         x = (x * x);
//     }

//     return res;
// }

// ll powerMod(ll x, ll y, ll p)
// {
//     ll res = 1;
//     x = x % p;

//     if (x == 0)
//         return 0;

//     while (y > 0)
//     {
//         if (y & 1)
//             res = (res * x) % p;
//         y = y >> 1;
//         x = (x * x) % p;
//     }

//     return res;
// }

// ll inverse(ll a) { return powerMod(a, mod - 2, mod); }

// int plusMod(int a, int b) { return ((a % mod) + (b % mod)) % mod; }
// int intoMod(int a, int b) { return ((a % mod) * (b % mod)) % mod; }
// int minusMod(int a, int b) { return ((a % mod) - (b % mod) + mod) % mod; }
// int divideMod(int a, int b) { return ((a % mod) * inverse(b) % mod) % mod; }

// ll lcm(ll a, ll b) { return (a / __gcd(a, b) * b); }

// vl fact(2e5 + 10, 1);
// int nCr(int n, int r)
// {
//     int lob = fact[n];
//     int hor = (fact[r] % mod * fact[n - r] % mod) % mod;
//     int ans = (lob % mod * inverse(hor) % mod) % mod;
//     return ans;
// }

class DSU // DSU obj(n)
{
public:
    vector<int> parent;

    DSU(int n)
    {
        parent.resize(n + 1);
        for (int i = 0; i <= n; i++)
        {
            parent[i] = i;
        }
    }

    void make_parent(int v)
    {
        parent[v] = v;
    }

    int find_root(int v)
    {
        if (v == parent[v])
            return v;
        return find_root(parent[v]);
    }

    void union_sets(int a, int b)
    {
        a = find_root(a);
        b = find_root(b);
        if (a != b)
            parent[b] = a;
    }

private:
    // private section
};

bool comparator(pair<ll, ll> a, pair<ll, ll> b) // sort(vp.begin(), vp.end(), comparator);
{
    if (a.first != a.second)
        return a.first < b.first;
    return a.second > b.second;
}

// int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, 1, -1};                               // 4 Direction
// int dx[] = {1, -1, 0, 0, 1, 1, -1, -1}, dy[] = {0, 0, 1, -1, 1, -1, 1, -1};   // 8 Direction
// int dx[] = {1, -1, 1, -1, 2, 2, -2, -2}, dy[] = {2, 2, -2, -2, 1, -1, 1, -1}; // Knight Direction
// int dx[] = {2, -2, 1, 1, -1, -1}, dy[] = {0, 0, 1, -1, 1, -1};                // Hexagonal Direction

// vector<vector<int>> a(n, vector<int>(n, 0));

void solve()
{
    int n;
    cin >> n;

    string a;
    cin >> a;

    for (int i = 0; i < n; i++)
    {
        if (a[i] == '0')
        {
            if (i - 1 >= 0 && a[i - 1] == '1')
            {
                a[i - 1] = '$';
                a[i] = '$';
            }
            else if (i + 1 < n && a[i + 1] == '1')
            {
                a[i + 1] = '$';
                a[i] = '$';
            }
        }
    }

    for (int i = 0; i < n; i++)
    {
        if (a[i] == '0')
        {
            cout << "No\n";
            return;
        }
    }
    cout << "Yes\n";
}

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    // #ifndef ONLINE_JUDGE
    // freopen("input.txt","r",stdin);
    // freopen("output.txt","w",stdout);
    // #endif

    int t = 1;
    cin >> t;

    for (int i = 1; i <= t; i++)
    {
        // cout << "Case " << i << ": ";
        solve();
    }

    return 0;
}
